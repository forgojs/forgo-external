{"version":3,"file":"forgo.js","mappings":";;;;;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,qBAAqB,GAAG,gBAAgB,GAAG,cAAc,GAAG,aAAa,GAAG,oBAAoB,GAAG,2BAA2B,GAAG,SAAS,GAAG,qBAAqB,GAAG,gBAAgB;AAC7M;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,qBAAqB,2BAA2B;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,8GAA8G,6BAA6B,cAAc;AACzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA,yDAAyD,kBAAkB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,WAAW,OAAO;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,2BAA2B,oCAAoC;AACtI,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yBAAyB;AAC1D;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yBAAyB;AAC1D;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,oHAAoH;AACrM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,6BAA6B,uBAAuB;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yBAAyB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uHAAuH,kCAAkC,cAAc;AACvK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;UC57BA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACN+B;;AAE/B;AACA,iBAAiB,kCAAK;AACtB","sources":["webpack://forgo-external/./node_modules/forgo/dist/index.js","webpack://forgo-external/webpack/bootstrap","webpack://forgo-external/webpack/runtime/make namespace object","webpack://forgo-external/./src/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setForgoState = exports.getForgoState = exports.rerender = exports.render = exports.mount = exports.setCustomEnv = exports.createForgoInstance = exports.h = exports.createElement = exports.Fragment = void 0;\n/*\n  Fragment constructor.\n  We simply use it as a marker in jsx-runtime.\n*/\nexports.Fragment = Symbol(\"FORGO_FRAGMENT\");\n/*\n  Namespaces\n*/\nconst HTML_NAMESPACE = \"http://www.w3.org/1999/xhtml\";\nconst MATH_NAMESPACE = \"http://www.w3.org/1998/Math/MathML\";\nconst SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\n/*\n  The element types we care about.\n  As defined by the standards.\n*/\nconst ELEMENT_NODE_TYPE = 1;\nconst ATTRIBUTE_NODE_TYPE = 2;\nconst TEXT_NODE_TYPE = 3;\n/*\n  jsxFactory function\n*/\nfunction createElement(type, props) {\n    var _a;\n    props = props !== null && props !== void 0 ? props : {};\n    props.children =\n        arguments.length > 3\n            ? flatten(Array.from(arguments).slice(2))\n            : arguments.length === 3\n                ? flatten(arguments[2])\n                : undefined;\n    const key = (_a = props.key) !== null && _a !== void 0 ? _a : undefined;\n    return { type, props, key, __is_forgo_element__: true };\n}\nexports.createElement = createElement;\nexports.h = createElement;\n/*\n  HACK: Chrome fires onblur (if defined) immediately after a node.remove().\n  This is bad news for us, since a rerender() inside the onblur handler will run on an unattached node.\n  So, disable onblur if node is set to be removed.\n*/\nfunction handlerDisabledOnNodeDelete(node, value) {\n    return (e) => {\n        if (!node.__forgo_deleted) {\n            return value(e);\n        }\n    };\n}\nfunction createForgoInstance(customEnv) {\n    var _a;\n    const env = customEnv;\n    env.__internal = (_a = env.__internal) !== null && _a !== void 0 ? _a : {\n        Text: env.window.Text,\n        HTMLElement: env.window.HTMLElement,\n    };\n    /*\n      This is the main render function.\n      forgoNode is the node to render.\n    \n      nodeInsertionOptions specify which nodes need to be replaced by the new node(s),\n      or whether the new node should be created detached from the DOM (without replacement).\n  \n      pendingAttachStates is the list of Component State objects which will be attached to the element.\n    */\n    function internalRender(forgoNode, nodeInsertionOptions, pendingAttachStates) {\n        // Array of Nodes\n        if (Array.isArray(forgoNode)) {\n            return renderArray(forgoNode, nodeInsertionOptions, pendingAttachStates);\n        }\n        // Primitive Nodes\n        else if (!isForgoElement(forgoNode)) {\n            return forgoNode === undefined || forgoNode === null\n                ? { nodes: [] }\n                : renderText(forgoNode, nodeInsertionOptions, pendingAttachStates);\n        }\n        // HTML Element\n        else if (isForgoDOMElement(forgoNode)) {\n            return renderDOMElement(forgoNode, nodeInsertionOptions, pendingAttachStates);\n        }\n        else if (isForgoFragment(forgoNode)) {\n            return renderFragment(forgoNode, nodeInsertionOptions, pendingAttachStates);\n        }\n        // Custom Component.\n        else {\n            return renderCustomComponent(forgoNode, nodeInsertionOptions, pendingAttachStates);\n        }\n    }\n    /*\n      Render a string.\n    \n      Such as in the render function below:\n      function MyComponent() {\n        return {\n          render() {\n            return \"Hello world\"\n          }\n        }\n      }\n    */\n    function renderText(forgoNode, nodeInsertionOptions, pendingAttachStates) {\n        // We need to create a detached node\n        if (nodeInsertionOptions.type === \"detached\") {\n            // Text nodes will always be recreated\n            const textNode = env.document.createTextNode(stringOfPrimitiveNode(forgoNode));\n            syncStateAndProps(forgoNode, textNode, textNode, pendingAttachStates);\n            return { nodes: [textNode] };\n        }\n        // We have to find a node to replace.\n        else {\n            // Text nodes will always be recreated\n            const textNode = env.document.createTextNode(stringOfPrimitiveNode(forgoNode));\n            // If we're searching in a list, we replace if the current node is a text node.\n            const childNodes = nodeInsertionOptions.parentElement.childNodes;\n            if (nodeInsertionOptions.length) {\n                let targetNode = childNodes[nodeInsertionOptions.currentNodeIndex];\n                if (targetNode.nodeType === TEXT_NODE_TYPE) {\n                    targetNode.replaceWith(textNode);\n                    syncStateAndProps(forgoNode, textNode, targetNode, pendingAttachStates);\n                    return { nodes: [textNode] };\n                }\n                else {\n                    const nextNode = childNodes[nodeInsertionOptions.currentNodeIndex];\n                    nodeInsertionOptions.parentElement.insertBefore(textNode, nextNode);\n                    syncStateAndProps(forgoNode, textNode, textNode, pendingAttachStates);\n                    return { nodes: [textNode] };\n                }\n            }\n            // There are no target nodes available\n            else {\n                const childNodes = nodeInsertionOptions.parentElement.childNodes;\n                if (childNodes.length === 0 ||\n                    nodeInsertionOptions.currentNodeIndex === 0) {\n                    nodeInsertionOptions.parentElement.prepend(textNode);\n                }\n                else {\n                    const nextNode = childNodes[nodeInsertionOptions.currentNodeIndex];\n                    nodeInsertionOptions.parentElement.insertBefore(textNode, nextNode);\n                }\n                syncStateAndProps(forgoNode, textNode, textNode, pendingAttachStates);\n                return { nodes: [textNode] };\n            }\n        }\n    }\n    /*\n      Render a DOM element.\n    \n      Such as in the render function below:\n      function MyComponent() {\n        return {\n          render() {\n            return <div>Hello world</div>\n          }\n        }\n      }\n    */\n    function renderDOMElement(forgoElement, nodeInsertionOptions, pendingAttachStates) {\n        // We need to create a detached node\n        if (nodeInsertionOptions.type === \"detached\") {\n            const newElement = addNewDOMElement(undefined, null);\n            return { nodes: [newElement] };\n        }\n        // We have to find a node to replace.\n        else {\n            const childNodes = nodeInsertionOptions.parentElement.childNodes;\n            if (nodeInsertionOptions.length) {\n                const searchResult = findReplacementCandidateForDOMElement(forgoElement, childNodes, nodeInsertionOptions.currentNodeIndex, nodeInsertionOptions.length);\n                if (searchResult.found) {\n                    // Get rid of unwanted nodes.\n                    unloadNodes(sliceDOMNodes(childNodes, nodeInsertionOptions.currentNodeIndex, searchResult.index), pendingAttachStates);\n                    const targetElement = childNodes[nodeInsertionOptions.currentNodeIndex];\n                    renderDOMChildNodes(targetElement);\n                    syncStateAndProps(forgoElement, targetElement, targetElement, pendingAttachStates);\n                    return { nodes: [targetElement] };\n                }\n                else {\n                    const newElement = addNewDOMElement(nodeInsertionOptions.parentElement, childNodes[nodeInsertionOptions.currentNodeIndex]);\n                    return { nodes: [newElement] };\n                }\n            }\n            else {\n                const newElement = addNewDOMElement(nodeInsertionOptions.parentElement, childNodes[nodeInsertionOptions.currentNodeIndex]);\n                return { nodes: [newElement] };\n            }\n        }\n        function renderDOMChildNodes(parentElement) {\n            if (forgoElement.props.dangerouslySetInnerHTML) {\n                parentElement.innerHTML =\n                    forgoElement.props.dangerouslySetInnerHTML.__html;\n            }\n            else {\n                const forgoChildrenObj = forgoElement.props.children;\n                // Children will not be an array if single item\n                const forgoChildren = flatten((Array.isArray(forgoChildrenObj)\n                    ? forgoChildrenObj\n                    : [forgoChildrenObj]).filter((x) => x !== undefined && x !== null));\n                let currentChildNodeIndex = 0;\n                for (const forgoChild of forgoChildren) {\n                    const { nodes } = internalRender(forgoChild, {\n                        type: \"search\",\n                        parentElement,\n                        currentNodeIndex: currentChildNodeIndex,\n                        length: parentElement.childNodes.length - currentChildNodeIndex,\n                    }, []);\n                    currentChildNodeIndex += nodes.length;\n                }\n                // Get rid the the remaining nodes\n                const nodesToRemove = sliceDOMNodes(parentElement.childNodes, currentChildNodeIndex, parentElement.childNodes.length);\n                if (nodesToRemove.length) {\n                    unloadNodes(nodesToRemove, []);\n                }\n            }\n        }\n        function addNewDOMElement(parentElement, oldNode) {\n            const newElement = createElement(forgoElement, parentElement);\n            if (parentElement) {\n                parentElement.insertBefore(newElement, oldNode);\n            }\n            if (forgoElement.props.ref) {\n                forgoElement.props.ref.value = newElement;\n            }\n            renderDOMChildNodes(newElement);\n            syncStateAndProps(forgoElement, newElement, newElement, pendingAttachStates);\n            return newElement;\n        }\n    }\n    /*\n      Render a Custom Component\n      Such as <MySideBar size=\"large\" />\n    */\n    function renderCustomComponent(forgoElement, nodeInsertionOptions, pendingAttachStates\n    // boundary: ForgoComponent<any> | undefined\n    ) {\n        const componentIndex = pendingAttachStates.length;\n        // We need to create a detached node\n        if (nodeInsertionOptions.type === \"detached\") {\n            return addNewComponent();\n        }\n        // We have to find a node to replace.\n        else {\n            if (nodeInsertionOptions.length) {\n                const childNodes = nodeInsertionOptions.parentElement.childNodes;\n                const searchResult = findReplacementCandidateForCustomComponent(forgoElement, childNodes, nodeInsertionOptions.currentNodeIndex, nodeInsertionOptions.length, pendingAttachStates.length);\n                if (searchResult.found) {\n                    const targetNode = childNodes[searchResult.index];\n                    const state = getExistingForgoState(targetNode);\n                    const componentState = state.components[componentIndex];\n                    // Get rid of unwanted nodes.\n                    unloadNodes(sliceDOMNodes(childNodes, nodeInsertionOptions.currentNodeIndex, searchResult.index), pendingAttachStates.concat(componentState));\n                    return renderExistingComponent(nodeInsertionOptions, componentState);\n                }\n                // No matching node found\n                else {\n                    // Wasn't found. Get rid of remaining nodes.\n                    unloadNodes(sliceDOMNodes(childNodes, nodeInsertionOptions.currentNodeIndex, childNodes.length), pendingAttachStates);\n                    return addNewComponent();\n                }\n            }\n            // No nodes in target node list\n            else {\n                return addNewComponent();\n            }\n        }\n        function renderExistingComponent(nodeInsertionOptions, componentState) {\n            if (!componentState.component.shouldUpdate ||\n                componentState.component.shouldUpdate(forgoElement.props, componentState.props)) {\n                // Since we have compatible state already stored,\n                // we'll push the savedComponentState into pending states for later attachment.\n                const newComponentState = Object.assign(Object.assign({}, componentState), { props: forgoElement.props });\n                const statesToAttach = pendingAttachStates.concat(newComponentState);\n                const previousNode = componentState.args.element.node;\n                // Get a new element by calling render on existing component.\n                const newForgoNode = newComponentState.component.render(forgoElement.props, newComponentState.args);\n                const boundary = newComponentState.component.error\n                    ? newComponentState.component\n                    : undefined;\n                const renderResult = withErrorBoundary(forgoElement.props, newComponentState.args, statesToAttach, boundary, () => {\n                    // Create new node insertion options.\n                    const insertionOptions = {\n                        type: \"search\",\n                        currentNodeIndex: nodeInsertionOptions.currentNodeIndex,\n                        length: newComponentState.nodes.length,\n                        parentElement: nodeInsertionOptions.parentElement,\n                    };\n                    return renderComponentAndRemoveStaleNodes(newForgoNode, insertionOptions, statesToAttach, newComponentState);\n                });\n                if (newComponentState.component.afterRender) {\n                    newComponentState.component.afterRender(forgoElement.props, Object.assign(Object.assign({}, newComponentState.args), { previousNode }));\n                }\n                return renderResult;\n            }\n            // shouldUpdate() returned false\n            else {\n                let indexOfNode = findDOMNodeIndex(nodeInsertionOptions.parentElement.childNodes, componentState.args.element.node);\n                return {\n                    nodes: sliceDOMNodes(nodeInsertionOptions.parentElement.childNodes, indexOfNode, indexOfNode + componentState.nodes.length),\n                };\n            }\n        }\n        function addNewComponent() {\n            const args = {\n                element: { componentIndex },\n                update: (props) => rerender(args.element, props),\n            };\n            const ctor = forgoElement.type;\n            const component = ctor(forgoElement.props, { environment: env });\n            assertIsComponent(ctor, component);\n            const boundary = component.error ? component : undefined;\n            // Create new component state\n            // ... and push it to pendingAttachStates\n            const newComponentState = {\n                key: forgoElement.key,\n                ctor,\n                component,\n                props: forgoElement.props,\n                args,\n                nodes: [],\n                isMounted: false,\n            };\n            const statesToAttach = pendingAttachStates.concat(newComponentState);\n            return withErrorBoundary(forgoElement.props, args, statesToAttach, boundary, () => {\n                // Create an element by rendering the component\n                const newForgoElement = component.render(forgoElement.props, args);\n                // Create new node insertion options.\n                const insertionOptions = nodeInsertionOptions.type === \"detached\"\n                    ? nodeInsertionOptions\n                    : {\n                        type: \"search\",\n                        currentNodeIndex: nodeInsertionOptions.currentNodeIndex,\n                        length: 0,\n                        parentElement: nodeInsertionOptions.parentElement,\n                    };\n                // Pass it on for rendering...\n                const renderResult = internalRender(newForgoElement, insertionOptions, statesToAttach);\n                // In case we rendered an array, set the node to the first node.\n                // We do this because args.element.node would be set to the last node otherwise.\n                newComponentState.nodes = renderResult.nodes;\n                if (renderResult.nodes.length > 1) {\n                    newComponentState.args.element.node = renderResult.nodes[0];\n                }\n                if (component.afterRender) {\n                    // No previousNode since new component. So just args and not afterRenderArgs.\n                    component.afterRender(forgoElement.props, args);\n                }\n                return renderResult;\n            });\n        }\n        function withErrorBoundary(props, args, statesToAttach, boundary, exec) {\n            try {\n                return exec();\n            }\n            catch (error) {\n                if (boundary && boundary.error) {\n                    const errorArgs = Object.assign(Object.assign({}, args), { error });\n                    const newForgoElement = boundary.error(props, errorArgs);\n                    return internalRender(newForgoElement, nodeInsertionOptions, statesToAttach);\n                }\n                else {\n                    throw error;\n                }\n            }\n        }\n    }\n    function renderComponentAndRemoveStaleNodes(forgoNode, insertionOptions, statesToAttach, componentState) {\n        const totalNodesBeforeRender = insertionOptions.parentElement.childNodes.length;\n        // Pass it on for rendering...\n        const renderResult = internalRender(forgoNode, insertionOptions, statesToAttach);\n        const totalNodesAfterRender = insertionOptions.parentElement.childNodes.length;\n        const numNodesRemoved = totalNodesBeforeRender +\n            renderResult.nodes.length -\n            totalNodesAfterRender;\n        const newIndex = insertionOptions.currentNodeIndex + renderResult.nodes.length;\n        const nodesToRemove = sliceDOMNodes(insertionOptions.parentElement.childNodes, newIndex, newIndex + componentState.nodes.length - numNodesRemoved);\n        unloadNodes(nodesToRemove, statesToAttach);\n        // In case we rendered an array, set the node to the first node.\n        // We do this because args.element.node would be set to the last node otherwise.\n        componentState.nodes = renderResult.nodes;\n        if (renderResult.nodes.length > 1) {\n            componentState.args.element.node = renderResult.nodes[0];\n        }\n        return renderResult;\n    }\n    /*\n      Render an array of components\n      Called when a CustomComponent returns an array (or fragment) in its render method.\n    */\n    function renderArray(forgoNodes, nodeInsertionOptions, pendingAttachStates) {\n        const flattenedNodes = flatten(forgoNodes);\n        if (nodeInsertionOptions.type === \"detached\") {\n            throw new Error(\"Arrays and fragments cannot be rendered at the top level.\");\n        }\n        else {\n            let allNodes = [];\n            let currentNodeIndex = nodeInsertionOptions.currentNodeIndex;\n            let numNodes = nodeInsertionOptions.length;\n            for (const forgoNode of flattenedNodes) {\n                const totalNodesBeforeRender = nodeInsertionOptions.parentElement.childNodes.length;\n                const insertionOptions = Object.assign(Object.assign({}, nodeInsertionOptions), { currentNodeIndex, length: numNodes });\n                const { nodes } = internalRender(forgoNode, insertionOptions, pendingAttachStates);\n                allNodes = allNodes.concat(nodes);\n                const totalNodesAfterRender = nodeInsertionOptions.parentElement.childNodes.length;\n                const numNodesRemoved = totalNodesBeforeRender + nodes.length - totalNodesAfterRender;\n                currentNodeIndex += nodes.length;\n                numNodes -= numNodesRemoved;\n            }\n            return { nodes: allNodes };\n        }\n    }\n    /*\n      Render a Fragment\n    */\n    function renderFragment(fragment, nodeInsertionOptions, pendingAttachStates) {\n        return renderArray(flatten(fragment), nodeInsertionOptions, pendingAttachStates);\n    }\n    /*\n      Sync component states and props between a newNode and an oldNode.\n    */\n    function syncStateAndProps(forgoNode, newNode, targetNode, pendingAttachStates) {\n        var _a;\n        // We have to get oldStates before attachProps;\n        // coz attachProps will overwrite with new states.\n        const oldComponentStates = (_a = getForgoState(targetNode)) === null || _a === void 0 ? void 0 : _a.components;\n        attachProps(forgoNode, newNode, pendingAttachStates);\n        if (oldComponentStates) {\n            const indexOfFirstIncompatibleState = findIndexOfFirstIncompatibleState(pendingAttachStates, oldComponentStates);\n            unmountComponents(oldComponentStates, indexOfFirstIncompatibleState);\n            mountComponents(pendingAttachStates, indexOfFirstIncompatibleState);\n        }\n        else {\n            mountComponents(pendingAttachStates, 0);\n        }\n    }\n    /*\n      Unloads components from a node list\n      This does:\n      a) Remove the node\n      b) Calls unload on all attached components\n    */\n    function unloadNodes(nodes, pendingAttachStates) {\n        for (const node of nodes) {\n            node.__forgo_deleted = true;\n            node.remove();\n            const state = getForgoState(node);\n            if (state) {\n                const oldComponentStates = state.components;\n                const indexOfFirstIncompatibleState = findIndexOfFirstIncompatibleState(pendingAttachStates, oldComponentStates);\n                unmountComponents(state.components, indexOfFirstIncompatibleState);\n            }\n        }\n    }\n    /*\n      When states are attached to a new node or when states are reattached,\n      some of the old component states need to go away.\n      The corresponding components will need to be unmounted.\n  \n      While rendering, the component gets reused if the ctor is the same.\n      If the ctor is different, the component is discarded. And hence needs to be unmounted.\n      So we check the ctor type in old and new.\n    */\n    function findIndexOfFirstIncompatibleState(newStates, oldStates) {\n        let i = 0;\n        for (const newState of newStates) {\n            if (oldStates.length > i) {\n                const oldState = oldStates[i];\n                if (oldState.component !== newState.component) {\n                    break;\n                }\n                i++;\n            }\n            else {\n                break;\n            }\n        }\n        return i;\n    }\n    /*\n      Unmount components above an index. This is going to be passed a stale state[].\n      The from param is the index at which stale state[] differs from new state[]\n    */\n    function unmountComponents(states, from) {\n        // If the parent has already unmounted, we can skip checks on children.\n        let parentHasUnmounted = false;\n        for (let i = from; i < states.length; i++) {\n            const state = states[i];\n            if (state.component.unmount) {\n                // Render if:\n                //  - parent has already unmounted\n                //  - OR for all nodes:\n                //  -   node is disconnected\n                //  -   OR node connected to a different component\n                if (parentHasUnmounted ||\n                    state.nodes.every((x) => {\n                        if (!x.isConnected) {\n                            return true;\n                        }\n                        else {\n                            const componentState = getExistingForgoState(x);\n                            return (!componentState.components[i] ||\n                                componentState.components[i].component !== state.component);\n                        }\n                    })) {\n                    state.component.unmount(state.props, state.args);\n                    parentHasUnmounted = true;\n                }\n            }\n        }\n    }\n    /*\n      Mount components above an index. This is going to be passed the new state[].\n      The from param is the index at which stale state[] differs from new state[]\n    */\n    function mountComponents(states, from) {\n        for (let i = from; i < states.length; i++) {\n            const state = states[i];\n            if (state.component.mount && !state.isMounted) {\n                state.isMounted = true;\n                state.component.mount(state.props, state.args);\n            }\n        }\n    }\n    /*\n      When we try to find replacement candidates for DOM nodes,\n      we try to:\n        a) match by the key\n        b) match by the tagname\n    */\n    function findReplacementCandidateForDOMElement(forgoElement, nodes, searchFrom, length) {\n        for (let i = searchFrom; i < searchFrom + length; i++) {\n            const node = nodes[i];\n            const stateOnNode = getForgoState(node);\n            if (forgoElement.key) {\n                if ((stateOnNode === null || stateOnNode === void 0 ? void 0 : stateOnNode.key) === forgoElement.key) {\n                    return { found: true, index: i };\n                }\n            }\n            else {\n                if (node.nodeType === ELEMENT_NODE_TYPE) {\n                    const element = node;\n                    // If the candidate has a key defined,\n                    //  we don't match it with an unkeyed forgo element\n                    if (element.tagName.toLowerCase() === forgoElement.type &&\n                        (!stateOnNode || !stateOnNode.key)) {\n                        return { found: true, index: i };\n                    }\n                }\n            }\n        }\n        return { found: false };\n    }\n    /*\n      When we try to find replacement candidates for Custom Components,\n      we try to:\n        a) match by the key\n        b) match by the component constructor\n    */\n    function findReplacementCandidateForCustomComponent(forgoElement, nodes, searchFrom, length, componentIndex) {\n        for (let i = searchFrom; i < searchFrom + length; i++) {\n            const node = nodes[i];\n            const stateOnNode = getForgoState(node);\n            if (stateOnNode && stateOnNode.components.length > componentIndex) {\n                if (forgoElement.key) {\n                    if (stateOnNode.components[componentIndex].key === forgoElement.key) {\n                        return { found: true, index: i };\n                    }\n                }\n                else {\n                    if (stateOnNode.components[componentIndex].ctor === forgoElement.type) {\n                        return { found: true, index: i };\n                    }\n                }\n            }\n        }\n        return { found: false };\n    }\n    /*\n      Attach props from the forgoElement on to the DOM node.\n      We also need to attach states from pendingAttachStates\n    */\n    function attachProps(forgoNode, node, pendingAttachStates) {\n        // Capture previous nodes if afterRender is defined;\n        const previousNodes = [];\n        // We have to inject node into the args object.\n        // components are already holding a reference to the args object.\n        // They don't know yet that args.element.node is undefined.\n        for (const state of pendingAttachStates) {\n            previousNodes.push(state.component.afterRender ? state.args.element.node : undefined);\n            state.args.element.node = node;\n        }\n        if (isForgoElement(forgoNode)) {\n            const currentState = getForgoState(node);\n            // Remove props which don't exist\n            if (currentState && currentState.props) {\n                for (const key in currentState.props) {\n                    if (!(key in forgoNode.props)) {\n                        if (key !== \"children\" && key !== \"xmlns\") {\n                            if (node.nodeType === TEXT_NODE_TYPE) {\n                                delete node[key];\n                            }\n                            else if (node instanceof env.__internal.HTMLElement) {\n                                if (node.hasAttribute(key)) {\n                                    node.removeAttribute(key);\n                                }\n                                else {\n                                    delete node[key];\n                                }\n                            }\n                            else {\n                                node.removeAttribute(key);\n                            }\n                        }\n                    }\n                }\n            }\n            // TODO: What preact does to figure out attr vs prop\n            //  - do a (key in element) check.\n            const entries = Object.entries(forgoNode.props);\n            for (const [key, value] of entries) {\n                if (key !== \"children\" && key !== \"xmlns\") {\n                    if (node.nodeType === TEXT_NODE_TYPE) {\n                        node[key] = value;\n                    }\n                    else if (node instanceof env.__internal.HTMLElement) {\n                        if (key === \"style\") {\n                            // Optimization: many times in CSS to JS, style objects are re-used.\n                            // If they're the same, skip the expensive styleToString() call.\n                            if (currentState === undefined ||\n                                currentState.style === undefined ||\n                                currentState.style !== forgoNode.props.style) {\n                                const stringOfCSS = styleToString(forgoNode.props.style);\n                                if (node.style.cssText !== stringOfCSS) {\n                                    node.style.cssText = stringOfCSS;\n                                }\n                            }\n                        }\n                        // This optimization is copied from preact.\n                        else if (typeof value === \"string\" &&\n                            (key.startsWith(\"aria-\") || key.startsWith(\"data-\"))) {\n                            node.setAttribute(key, value);\n                        }\n                        else if (key === \"onblur\") {\n                            node[key] = handlerDisabledOnNodeDelete(node, value);\n                        }\n                        else {\n                            node[key] = value;\n                        }\n                    }\n                    else {\n                        if (typeof value === \"string\") {\n                            node.setAttribute(key, value);\n                        }\n                        else {\n                            node[key] = value;\n                        }\n                    }\n                }\n            }\n            // Now attach the internal forgo state.\n            const state = {\n                key: forgoNode.key,\n                props: forgoNode.props,\n                components: pendingAttachStates,\n            };\n            setForgoState(node, state);\n        }\n        else {\n            // Now attach the internal forgo state.\n            const state = {\n                components: pendingAttachStates,\n            };\n            setForgoState(node, state);\n        }\n    }\n    /*\n      Mount will render the DOM as a child of the specified container element.\n    */\n    function mount(forgoNode, container) {\n        let parentElement = (isString(container) ? env.document.querySelector(container) : container);\n        if (parentElement) {\n            if (parentElement.nodeType === ELEMENT_NODE_TYPE) {\n                return internalRender(forgoNode, {\n                    type: \"search\",\n                    currentNodeIndex: 0,\n                    length: parentElement.childNodes.length,\n                    parentElement,\n                }, []);\n            }\n            else {\n                throw new Error(\"The container argument to the mount() function should be an HTML element.\");\n            }\n        }\n        else {\n            throw new Error(`The mount() function was called on a non-element (${typeof container === \"string\" ? container : container === null || container === void 0 ? void 0 : container.tagName}).`);\n        }\n    }\n    /*\n      This render function returns the rendered dom node.\n      forgoNode is the node to render.\n    */\n    function render(forgoNode) {\n        const renderResult = internalRender(forgoNode, {\n            type: \"detached\",\n        }, []);\n        return { node: renderResult.nodes[0], nodes: renderResult.nodes };\n    }\n    /*\n      Code inside a component will call rerender whenever it wants to rerender.\n      The following function is what they'll need to call.\n  \n      Given only a DOM element, how do we know what component to render?\n      We'll fetch all that information from the state information stored on the element.\n  \n      This is attached to a node inside a NodeAttachedState structure.\n    */\n    function rerender(element, props) {\n        if (element && element.node) {\n            const parentElement = element.node.parentElement;\n            if (parentElement !== null) {\n                const state = getForgoState(element.node);\n                if (state) {\n                    const originalComponentState = state.components[element.componentIndex];\n                    const effectiveProps = props !== undefined ? props : originalComponentState.props;\n                    if (!originalComponentState.component.shouldUpdate ||\n                        originalComponentState.component.shouldUpdate(effectiveProps, originalComponentState.props)) {\n                        const newComponentState = Object.assign(Object.assign({}, originalComponentState), { props: effectiveProps });\n                        const parentStates = state.components.slice(0, element.componentIndex);\n                        const statesToAttach = parentStates.concat(newComponentState);\n                        const previousNode = originalComponentState.args.element.node;\n                        const forgoNode = originalComponentState.component.render(effectiveProps, originalComponentState.args);\n                        let nodeIndex = findDOMNodeIndex(parentElement.childNodes, element.node);\n                        const insertionOptions = {\n                            type: \"search\",\n                            currentNodeIndex: nodeIndex,\n                            length: originalComponentState.nodes.length,\n                            parentElement,\n                        };\n                        const renderResult = renderComponentAndRemoveStaleNodes(forgoNode, insertionOptions, statesToAttach, newComponentState);\n                        // We have to propagate node changes up the tree.\n                        for (let i = 0; i < parentStates.length; i++) {\n                            const parentState = parentStates[i];\n                            const indexOfOriginalRootNode = parentState.nodes.findIndex((x) => x === originalComponentState.nodes[0]);\n                            // Let's recreate the node list.\n                            parentState.nodes = parentState.nodes\n                                // 1. all the nodes before first node associated with rendered component.\n                                .slice(0, indexOfOriginalRootNode)\n                                // 2. newly created nodes.\n                                .concat(renderResult.nodes)\n                                // 3. nodes after last node associated with rendered component.\n                                .concat(parentState.nodes.slice(indexOfOriginalRootNode +\n                                originalComponentState.nodes.length));\n                            // If there are no nodes, call unmount on it (and child states)\n                            if (parentState.nodes.length === 0) {\n                                unmountComponents(parentStates, i);\n                                break;\n                            }\n                            else {\n                                // The root node might have changed, so fix it up anyway.\n                                parentState.args.element.node = parentState.nodes[0];\n                            }\n                        }\n                        // Unmount rendered component itself if all nodes are gone.\n                        if (renderResult.nodes.length === 0) {\n                            unmountComponents([newComponentState], 0);\n                        }\n                        // Run afterRender() if defined.\n                        if (originalComponentState.component.afterRender) {\n                            originalComponentState.component.afterRender(effectiveProps, Object.assign(Object.assign({}, originalComponentState.args), { previousNode }));\n                        }\n                        return renderResult;\n                    }\n                    // shouldUpdate() returned false\n                    else {\n                        let indexOfNode = findDOMNodeIndex(parentElement.childNodes, element.node);\n                        return {\n                            nodes: sliceDOMNodes(parentElement.childNodes, indexOfNode, indexOfNode + originalComponentState.nodes.length),\n                        };\n                    }\n                }\n                else {\n                    throw new Error(`Missing forgo state on node.`);\n                }\n            }\n            else {\n                throw new Error(`The rerender() function was called on a node without a parent element.`);\n            }\n        }\n        else {\n            throw new Error(`Missing node information in rerender() argument.`);\n        }\n    }\n    function createElement(forgoElement, parentElement) {\n        var _a;\n        const namespaceURI = ((_a = forgoElement.props.xmlns) !== null && _a !== void 0 ? _a : forgoElement.type === \"svg\")\n            ? SVG_NAMESPACE\n            : parentElement && parentElement.namespaceURI;\n        if (forgoElement.props.is) {\n            return namespaceURI\n                ? env.document.createElementNS(namespaceURI, forgoElement.type, {\n                    is: forgoElement.props.is,\n                })\n                : env.document.createElement(forgoElement.type, {\n                    is: forgoElement.props.is,\n                });\n        }\n        else {\n            return namespaceURI\n                ? env.document.createElementNS(namespaceURI, forgoElement.type)\n                : env.document.createElement(forgoElement.type);\n        }\n    }\n    return {\n        mount,\n        render,\n        rerender,\n    };\n}\nexports.createForgoInstance = createForgoInstance;\nconst windowObject = globalThis ? globalThis : window;\nlet forgoInstance = createForgoInstance({\n    window: windowObject,\n    document: windowObject.document,\n});\nfunction setCustomEnv(customEnv) {\n    forgoInstance = createForgoInstance(customEnv);\n}\nexports.setCustomEnv = setCustomEnv;\nfunction mount(forgoNode, container) {\n    return forgoInstance.mount(forgoNode, container);\n}\nexports.mount = mount;\nfunction render(forgoNode) {\n    return forgoInstance.render(forgoNode);\n}\nexports.render = render;\nfunction rerender(element, props) {\n    return forgoInstance.rerender(element, props);\n}\nexports.rerender = rerender;\n/*\n  This recursively flattens an array or a Fragment.\n  Fragments are treated as arrays, with the children prop being array items.\n*/\nfunction flatten(itemOrItems, ret = []) {\n    const items = Array.isArray(itemOrItems)\n        ? itemOrItems\n        : isForgoFragment(itemOrItems)\n            ? Array.isArray(itemOrItems.props.children)\n                ? itemOrItems.props.children\n                : itemOrItems.props.children !== undefined &&\n                    itemOrItems.props.children !== null\n                    ? [itemOrItems.props.children]\n                    : []\n            : [itemOrItems];\n    for (const entry of items) {\n        if (Array.isArray(entry) || isForgoFragment(entry)) {\n            flatten(entry, ret);\n        }\n        else {\n            ret.push(entry);\n        }\n    }\n    return ret;\n}\n/*\n  ForgoNodes can be primitive types.\n  Convert all primitive types to their string representation.\n*/\nfunction stringOfPrimitiveNode(node) {\n    return node.toString();\n}\n/*\n  Get Node Types\n*/\nfunction isForgoElement(forgoNode) {\n    return (forgoNode !== undefined &&\n        forgoNode !== null &&\n        forgoNode.__is_forgo_element__ === true);\n}\nfunction isForgoDOMElement(node) {\n    return isForgoElement(node) && typeof node.type === \"string\";\n}\nfunction isForgoFragment(node) {\n    return node !== undefined && node !== null && node.type === exports.Fragment;\n}\n/*\n  Get the state (NodeAttachedState) saved into an element.\n*/\nfunction getForgoState(node) {\n    return node.__forgo;\n}\nexports.getForgoState = getForgoState;\n/*\n  Same as above, but throws if undefined. (Caller must make sure.)\n*/\nfunction getExistingForgoState(node) {\n    if (node.__forgo) {\n        return node.__forgo;\n    }\n    else {\n        throw new Error(\"Missing state in node.\");\n    }\n}\n/*\n  Sets the state (NodeAttachedState) on an element.\n*/\nfunction setForgoState(node, state) {\n    node.__forgo = state;\n}\nexports.setForgoState = setForgoState;\n/*\n  Throw if component is a non-component\n*/\nfunction assertIsComponent(ctor, component) {\n    if (!component.render) {\n        throw new Error(`${ctor.name || \"Unnamed\"} component constructor must return an object having a render() function.`);\n    }\n}\nfunction isString(val) {\n    return typeof val === \"string\";\n}\n// Thanks Artem Bochkarev\nfunction styleToString(style) {\n    if (typeof style === \"string\") {\n        return style;\n    }\n    else if (style === undefined || style === null) {\n        return \"\";\n    }\n    else {\n        return Object.keys(style).reduce((acc, key) => acc +\n            key\n                .split(/(?=[A-Z])/)\n                .join(\"-\")\n                .toLowerCase() +\n            \":\" +\n            style[key] +\n            \";\", \"\");\n    }\n}\n/* parentElements.childNodes is not an array. A slice() for it. */\nfunction sliceDOMNodes(domNodes, from, to) {\n    const result = [];\n    for (let i = from; i < to; i++) {\n        result.push(domNodes[i]);\n    }\n    return result;\n}\n/* parentElements.childNodes is not an array. A findIndex() for it. */\nfunction findDOMNodeIndex(domNodes, element) {\n    for (let i = 0; i < domNodes.length; i++) {\n        if (domNodes[i] === element) {\n            return i;\n        }\n    }\n    return -1;\n}\n//# sourceMappingURL=index.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import * as forgo from \"forgo\";\n\nif (window && !window.forgo) {\n  window.forgo = forgo;\n}\n"],"names":[],"sourceRoot":""}